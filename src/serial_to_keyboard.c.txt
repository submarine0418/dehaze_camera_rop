// serial_to_keyboard.c - æ”¹é€²ç‰ˆ
#include <fcntl.h>
#include <linux/input.h>
#include <linux/uinput.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <termios.h>
#include <signal.h>
#include <errno.h>

int uinput_fd = -1;
int serial_fd = -1;

void cleanup(int sig) {
    printf("\nCleaning up...\n");
    
    if (uinput_fd >= 0) {
        ioctl(uinput_fd, UI_DEV_DESTROY);
        close(uinput_fd);
    }
    if (serial_fd >= 0) {
        close(serial_fd);
    }
    
    printf("Exited.\n");
    exit(0);
}

void emit(int fd, int type, int code, int value) {
    struct input_event ev;
    memset(&ev, 0, sizeof(ev));
    
    ev.type = type;
    ev.code = code;
    ev.value = value;
    
    // è®“ kernel è‡ªå‹•è¨­å®šæ™‚é–“
    gettimeofday(&ev.time, NULL);
    
    if (write(fd, &ev, sizeof(ev)) < 0) {
        perror("write event failed");
    }
}

int main(int argc, char *argv[]) {
    if (argc != 2) {
        fprintf(stderr, "Usage: sudo %s /dev/ttyACM0\n", argv[0]);
        return 1;
    }

    signal(SIGINT, cleanup);
    signal(SIGTERM, cleanup);

    // === é–‹å•Ÿ Serial Port ===
    printf("Opening serial port: %s\n", argv[1]);
    
    serial_fd = open(argv[1], O_RDONLY | O_NOCTTY);
    if (serial_fd < 0) {
        perror("Failed to open serial port");
        return 1;
    }

    // è¨­å®š Serial Port
    struct termios tty;
    memset(&tty, 0, sizeof(tty));
    
    if (tcgetattr(serial_fd, &tty) != 0) {
        perror("tcgetattr failed");
        close(serial_fd);
        return 1;
    }

    // 115200 baud, 8N1
    cfsetospeed(&tty, B115200);
    cfsetispeed(&tty, B115200);
    
    tty.c_cflag = (tty.c_cflag & ~CSIZE) | CS8;  // 8-bit
    tty.c_cflag |= (CLOCAL | CREAD);             // å•Ÿç”¨æ¥æ”¶
    tty.c_cflag &= ~(PARENB | PARODD);           // ç„¡ parity
    tty.c_cflag &= ~CSTOPB;                      // 1 stop bit
    tty.c_cflag &= ~CRTSCTS;                     // ç„¡ç¡¬é«”æµæ§
    
    tty.c_iflag &= ~(IXON | IXOFF | IXANY);      // ç„¡è»Ÿé«”æµæ§
    tty.c_iflag &= ~(IGNBRK|BRKINT|PARMRK|ISTRIP|INLCR|IGNCR|ICRNL);
    
    tty.c_lflag = 0;                             // é canonical mode
    tty.c_oflag = 0;                             // ç„¡è¼¸å‡ºè™•ç†
    
    tty.c_cc[VMIN] = 1;   // è‡³å°‘è®€ 1 å€‹å­—å…ƒ
    tty.c_cc[VTIME] = 1;  // 0.1 ç§’ timeout
    
    if (tcsetattr(serial_fd, TCSANOW, &tty) != 0) {
        perror("tcsetattr failed");
        close(serial_fd);
        return 1;
    }
    
    printf("âœ“ Serial port configured\n");
    
    // æ¸…ç©º buffer
    tcflush(serial_fd, TCIFLUSH);

    // === é–‹å•Ÿ uinput ===
    printf("Opening /dev/uinput...\n");
    
    uinput_fd = open("/dev/uinput", O_WRONLY | O_NONBLOCK);
    if (uinput_fd < 0) {
        perror("Failed to open /dev/uinput (éœ€è¦ sudo)");
        close(serial_fd);
        return 1;
    }

    // å•Ÿç”¨æŒ‰éµäº‹ä»¶
    ioctl(uinput_fd, UI_SET_EVBIT, EV_KEY);
    ioctl(uinput_fd, UI_SET_KEYBIT, KEY_W);
    ioctl(uinput_fd, UI_SET_KEYBIT, KEY_A);
    ioctl(uinput_fd, UI_SET_KEYBIT, KEY_S);
    ioctl(uinput_fd, UI_SET_KEYBIT, KEY_D);

    // è¨­å®šè™›æ“¬è¨­å‚™è³‡è¨Š
    struct uinput_setup usetup;
    memset(&usetup, 0, sizeof(usetup));
    
    usetup.id.bustype = BUS_USB;
    usetup.id.vendor = 0x2341;   // Arduino VID
    usetup.id.product = 0x0043;  // Uno PID
    usetup.id.version = 1;
    strcpy(usetup.name, "Arduino-Joystick-WASD");

    if (ioctl(uinput_fd, UI_DEV_SETUP, &usetup) < 0) {
        perror("UI_DEV_SETUP failed");
        close(uinput_fd);
        close(serial_fd);
        return 1;
    }

    // å‰µå»ºè¨­å‚™
    if (ioctl(uinput_fd, UI_DEV_CREATE) < 0) {
        perror("UI_DEV_CREATE failed");
        close(uinput_fd);
        close(serial_fd);
        return 1;
    }

    printf("âœ“ uinput device created\n");
    sleep(1);  // ç­‰å¾…è¨­å‚™ç©©å®š

    // === ä¸»è¿´åœˆ ===
    printf("\nğŸ® Arduino Joystick â†’ WASD Keyboard\n");
    printf("Press Ctrl+C to exit\n\n");

    // æŒ‰éµæ˜ å°„
    int key_map[256] = {0};
    key_map['W'] = KEY_W;
    key_map['A'] = KEY_A;
    key_map['S'] = KEY_S;
    key_map['D'] = KEY_D;
    
    char buffer[256];
    int pos = 0;
    char c;

    while (1) {
        int n = read(serial_fd, &c, 1);
        
        if (n < 0) {
            if (errno == EAGAIN || errno == EWOULDBLOCK) {
                usleep(1000);
                continue;
            }
            perror("read failed");
            break;
        }
        
        if (n == 0) {
            usleep(1000);
            continue;
        }

        // æ”¶é›†å®Œæ•´çš„ä¸€è¡Œ
        if (c == '\n' || c == '\r') {
            if (pos > 0) {
                buffer[pos] = '\0';
                
                // è§£ææŒ‰éµ
                char key_char = buffer[0];
                
                if (key_map[(int)key_char]) {
                    int key_code = key_map[(int)key_char];
                    
                    printf("Key: %c\n", key_char);
                    
                    // æŒ‰ä¸‹
                    emit(uinput_fd, EV_KEY, key_code, 1);
                    emit(uinput_fd, EV_SYN, SYN_REPORT, 0);
                    
                    // å»¶é² (æ¨¡æ“¬æŒ‰éµæ™‚é–“)
                    usleep(50000);  // 50ms
                    
                    // æ”¾é–‹
                    emit(uinput_fd, EV_KEY, key_code, 0);
                    emit(uinput_fd, EV_SYN, SYN_REPORT, 0);
                }
                
                pos = 0;
            }
        } else if (pos < sizeof(buffer) - 1) {
            buffer[pos++] = c;
        }
    }

    cleanup(0);
    return 0;
}